load(":setting.bzl", "validate_and_get_attr_name")

visibility("private")

def make_wrapper(*, rule_info, frontend, transitioning_alias, values):
    return lambda *, name, **kwargs: _wrapper(
        name = name,
        kwargs = kwargs,
        rule_info = rule_info,
        frontend = frontend,
        transitioning_alias = transitioning_alias,
        values = values,
    )

# Attributes common to all rules.
# These attributes are applied to all targets generated by the wrapper.
# testonly, tags and visibility are handled specially.
_COMMON_ATTRS = [
    # keep sorted
    "compatible_with",
    "deprecation",
    "exec_compatible_with",
    "exec_properties",
    "features",
    "restricted_to",
    "target_compatible_with",
]

# Attributes common to all executable and test rules.
# These attributes are applied to the original target and the frontend if the original target is
# executable.
# env and env_inherit are covered by the forwarded RunEnvironmentInfo instead.
_EXECUTABLE_ATTRS = [
    # keep sorted
    "args",
]

# Attributes common to all test rules.
# These attributes are applied to the original target and the frontend if the original target is a
# test.
# env and env_inherit are covered by the forwarded RunEnvironmentInfo instead.
_TEST_ATTRS = [
    # keep sorted
    "args",
    "flaky",
    "local",
    "shard_count",
    "size",
    "timeout",
]

def _wrapper(*, name, kwargs, rule_info, frontend, transitioning_alias, values):
    tags = kwargs.pop("tags", None)
    if not tags:
        tags_with_manual = ["manual"]
    elif "manual" not in tags:
        tags_with_manual = tags + ["manual"]
    else:
        tags_with_manual = tags

    visibility = kwargs.pop("visibility", None)
    common_attrs = {
        attr: kwargs.pop(attr, None)
        for attr in _COMMON_ATTRS
    }

    # Due to --trim_test_configuration, all targets that depend on tests (such as our
    # transitioning_alias) must be marked as testonly to avoid action conflicts.
    common_attrs["testonly"] = kwargs.pop("testonly", True if rule_info.test else None)

    if rule_info.test:
        extra_attrs = {
            attr: kwargs.pop(attr, None)
            for attr in _TEST_ATTRS
        }
    elif rule_info.executable:
        extra_attrs = {
            attr: kwargs.pop(attr, None)
            for attr in _EXECUTABLE_ATTRS
        }
    else:
        extra_attrs = {}

    # Native rules use magic "env" and "env_inherit" attributes to set environment variables. We
    # have to implement these attributes manually as they aren't forwarded via RunEnvironmentInfo.
    if rule_info.native and (rule_info.executable or rule_info.test):
        extra_attrs["env"] = kwargs.pop("env", None)
        extra_attrs["env_inherit"] = kwargs.pop("env_inherit", None)

    dirname, separator, basename = name.rpartition("/")
    original_name = "{dirname}{separator}{basename}_/{basename}".format(
        dirname = dirname,
        separator = separator,
        basename = basename,
    )
    alias_name = name + "_with_cfg"

    rule_info.kind(
        name = original_name,
        tags = tags_with_manual,
        visibility = ["//visibility:private"],
        **(kwargs | common_attrs | extra_attrs)
    )

    value_attrs = {
        validate_and_get_attr_name(setting): value
        for setting, value in values.items()
    }

    transitioning_alias(
        name = alias_name,
        exports = ":" + original_name,
        tags = tags_with_manual,
        visibility = ["//visibility:private"],
        **(value_attrs | common_attrs)
    )

    frontend(
        name = name,
        exports = ":" + alias_name,
        tags = tags,
        visibility = visibility,
        **(common_attrs | extra_attrs)
    )

    for implicit_target in rule_info.implicit_targets:
        sub_name = "{dirname}{separator}{sub_basename}".format(
            dirname = dirname,
            separator = separator,
            sub_basename = implicit_target.format(basename),
        )
        original_sub_name = "{dirname}{separator}{basename}_/{sub_basename}".format(
            dirname = dirname,
            separator = separator,
            basename = basename,
            sub_basename = implicit_target.format(basename),
        )
        transitioning_alias(
            name = sub_name,
            exports = ":" + original_sub_name,
            tags = tags_with_manual,
            visibility = visibility,
            **(value_attrs | common_attrs)
        )
